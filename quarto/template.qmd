---
title: "`r params$project_name`"
subtitle: "`r params$year`"
prefer-html: true
format:
  html: 
    toc: true
    toc-depth: 4
    toc-location: left
    link-external-newwindow: true
    embed-resources: true
    css: styles/styles.css
    format-links: false
  docx: 
    toc: false
    reference-doc: styles/word-template.docx
execute:
  echo: false
  warning: false
  message: false
  output: true
knitr: 
  opts_chunk:
    dev: "ragg_png"
    tbl.cap: NULL
    ft.align: "left"
format-links: false
fig-align: left
fig-width: 6
fig-height: 3.5
fig-dpi: 300
params:
  data_file: "spanish-test.xlsx"
  year: "2023"
  language: "spanish"
  producer_id: "WUY05"
  project_name: "Sample Project"
  soil_depth: "0-12 inches"
  project_summary: "This is a summary."
  looking_forward: "Next steps include more analysis."
  measures: ["def-texture.qmd", "def-bulk-density.qmd", "def-soil-ph.qmd", "def-total-nitro.qmd","def-min-c.qmd"]
---

```{r set-up}
library(systemfonts)
library(webshot2)
library(soils)
library(tidyverse)
library(flextable)
library(readxl)
library(glue)

# Get output file type
out_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")

# Set path for saving figure output
path <- here::here("figure-output/")

# Delete figure output directory if it already exists
if (fs::dir_exists(path)) fs::dir_delete(path)

# Create fresh figure output directory
fs::dir_create(path)
```

```{r set-fonts-colors}
#| output: false

# Get the list of available font families
fonts <- system_fonts()
families <- unique(fonts$family)

# Check if Arial is available
if (!("Arial" %in% families)) {
  systemfonts::register_font(
    name = "Arial",
    plain = "www/fonts/Arial.ttf",
    bold = "www/fonts/Arial-Bold.ttf",
    italic = "www/fonts/Arial-Italic.ttf",
    bolditalic = "www/fonts/Arial-Bold-Italic.ttf"
  )
  message("Arial font registered successfully.")
} else {
  message("Arial font is already registered.")
}

# EDIT: Replace any font names and colors to match your branding.
header_font <- "Georgia"
body_font <- "Arial"

# Group header colors
section_colors <- data.frame(
  name = c("Biological", "Physical", "Chemical"),
  color = c("#335c67", "#a60f2d", "#d4820a")
)

# Flextable colors -----------------------------------------------------
# header background color
header_color <- "#023B2C"
# header text color
header_text_color <- "white"
# body darker background color
darker_color <- "#ccc29c"
# body lighter background color
lighter_color <- "#F2F0E6"
# border color
border_color <- "#3E3D3D"

# Map and plot colors -----------------------------------------------------
# point color for producer samples
primary_color <- "#a60f2d"
# point color for samples in same categories as producer
secondary_color <- "#3E3D3D"
# point color for all other samples in project
other_color <- "#ccc29c"
# facet strip background color
strip_color <- "#335c67"
# facet strip text color
strip_text_color <- "white"
```

<!-- FUNCTION TO FETCH SECTION TEXT FROM TEXT.MD FILE -->
```{r text-function}
get_text <- function(section = "intro", content_dir = "english") {
  file <- file.path(content_dir, paste0("text.md"))
  if (!file.exists(file)) stop("Translation file not found for language")

  lines <- readLines(file, warn = FALSE)

  section_start <- grep(paste0("<!--section:", section, "-->"), lines)
  if (length(section_start) == 0) stop("Section not found: ", section)

  section_end <- grep("<!--section:", lines)
  section_end <- section_end[section_end > section_start][1]
  if (is.na(section_end)) section_end <- length(lines) + 1

  paste(lines[(section_start + 1):(section_end - 1)], collapse = "\n")
}

parse_bullets_from_markdown <- function(section, content_dir = "english") {
  # Read raw markdown section
  raw_text <- get_text(section = section, content_dir = content_dir)
  lines <- strsplit(raw_text, "\n")[[1]]

  # Extract the title (line starting with ##)
  title_line <- grep("^##\\s+", lines, value = TRUE)
  title <- sub("^##\\s+", "", title_line)

  # Extract bullet lines (lines starting with - or •)
  bullet_lines <- grep("^\\s*[-•]\\s+", lines, value = TRUE)
  bullet_lines <- gsub("^\\s*[-•]\\s+", "• ", bullet_lines)

  # Create a named list (or convert to data frame)
  df <- data.frame(setNames(list(bullet_lines), title), check.names = FALSE)
  return(df)
}

lang_map <- yaml::read_yaml(file.path(params$language, "mapping.yml"))

tr <- function(key) {
  lang_map[[key]] %||% key
}
```

```{r read-data}
### SET UP MEASUREMENT DEFINITIONS
measures <- unlist(strsplit(params$measures, ","))
measurement_dictionary <- read.csv(paste0(params$language, "/measurement_dictionary.csv"))

# filtered dictionary
selected_measures <- measurement_dictionary |> filter(file_name %in% measures)

# unique measure types, e.g. Biological, Physical, Etc
distinct_selected_measure_types <- selected_measures |>
  distinct(section_name) |>
  pull(section_name)

### READ IN DATA FILE
data <- readxl::read_xlsx(params$data_file, sheet = "Data")

dictionary <- readxl::read_xlsx(params$data_file, sheet = "Data Dictionary") |>
  dplyr::mutate(
    # Concatenate abbr and unit with html break for the table and plot labels
    abbr_unit = glue::glue("{abbr}<br>{unit}"),
    # Remove NA if unit is blank
    abbr_unit = gsub("NA", "", abbr_unit),
    # Set the order of how measurement groups will appear within the report
    # based on the order found in the data dictionary
    group_order = dplyr::cur_group_id(),
    # Set the order of how measurements will appear within each measurement
    # group based on the order found in the data dictionary
    measurement_order = seq_along(column_name),
    .by = measurement_group
  )

# Get vector of measurement groups from dictionary
measurement_groups <- unique(dictionary$measurement_group)
```


```{r tidy-long}
# Tidy data and join with dictionary
num_cols <- ncol(data)

# Tidy data into long format and join with data dictionary
results_long <- data |>
  dplyr::mutate(
    dplyr::across(
      # EDIT: replace with the column range of your soil measurements
      12:num_cols,
      as.numeric
    )
  ) |>
  tidyr::pivot_longer(
    # EDIT: replace with the column range of your soil measurements
    cols = 12:num_cols,
    names_to = "measurement"
  ) |>
  dplyr::inner_join(dictionary, by = c("measurement" = "column_name")) |>
  dplyr::mutate(
    group_order = factor(
      group_order,
      levels = unique(dictionary$group_order),
      ordered = unique(is.ordered(dictionary$group_order))
    ),
    abbr = factor(
      abbr,
      levels = dictionary$abbr,
      ordered = is.ordered(dictionary$measurement_order)
    ),
    abbr_unit = factor(
      abbr_unit,
      levels = dictionary$abbr_unit,
      ordered = is.ordered(dictionary$measurement_order)
    )
  ) |>
  dplyr::arrange(group_order, measurement_order) |>
  dplyr::filter(!is.na(value))
```

```{r get-producer-info}
# Ensure 'farm_name' and 'field_name' exist; create if missing
if (!"farm_name" %in% names(results_long)) results_long$farm_name <- NA
if (!"field_name" %in% names(results_long)) results_long$field_name <- NA

# Fill missing farm/field names with fallback labels
results_long$farm_name <- ifelse(
  is.na(results_long$farm_name),
  glue::glue("Farm {params$producer_id}"),
  results_long$farm_name
)
results_long$field_name <- ifelse(
  is.na(results_long$field_name),
  glue::glue("Field {results_long$field_id}"),
  results_long$field_name
)

# Subset to producer samples
producer_samples <- results_long |>
  dplyr::filter(producer_id == params$producer_id & year == params$year)

# Abort if there are no producer samples
if (nrow(producer_samples) == 0) {
  cli::cli_abort(c(
    "i" = "Update {.code params} in YAML to a valid {.code producer_id} and\
    {.code year} combo.",
    "x" = "{.code {params$producer_id}} and {.code {params$year}} must exist\
     in your data."
  ))
}

# Extract producer sample IDs, crops, counties, and farm name into
# producer list
producer <- list("sample_id", "crop", "county", "farm_name", "measurement") |>
  rlang::set_names() |>
  purrr::map(\(x) soils::pull_unique(
    df = producer_samples,
    target = x
  ))

# In case of multiple farm names, grab first one
producer$farm_name <- if (producer$farm_name > 1) producer$farm_name[[1]]

# Remove measurements that producer did not have tested
results_long <- results_long |>
  dplyr::filter(measurement %in% producer_samples$measurement)
```

<!-- GIS data prep -->

```{r prep-gis-df}
# Prep data for GIS table and map
gis_df <- soils::prep_for_map(
  producer_samples,
  label_heading = field_id,
  # If crop is empty, omit from popup
  label_body = ifelse(!is.na(crop), crop, "")
)
```


```{r calculate-averages}
# Calculate averages by crop, county, and project
crop_summary <- results_long |>
  dplyr::filter(!is.na(crop)) |>
  soils::summarize_by_var(
    producer_samples,
    var = crop
  ) |>
  dplyr::mutate(
    `Field or Average` = gsub("Fields", tr("fields"), `Field or Average`),
    `Field or Average` = gsub("Average", tr("average"), `Field or Average`)
  ) |>
  dplyr::rename(
    !!tr("field_or_average") := `Field or Average`,
    !!tr("texture") := Texture
  )

county_summary <- results_long |>
  dplyr::filter(!is.na(county)) |>
  soils::summarize_by_var(
    producer_samples,
    var = county
  ) |>
  dplyr::mutate(
    `Field or Average` = gsub("Fields", tr("fields"), `Field or Average`),
    `Field or Average` = gsub("Average", tr("average"), `Field or Average`)
  ) |>
  dplyr::rename(
    !!tr("field_or_average") := `Field or Average`,
    !!tr("texture") := Texture
  )

project_summary <- soils::summarize_by_project(results_long) |>
  dplyr::mutate(
    `Field or Average` = gsub(
      "Fields",
      tr("fields"),
      `Field or Average`
    ),
    `Field or Average` = gsub(
      "Project Average",
      tr("project_average"),
      `Field or Average`
    )
  ) |>
  dplyr::rename(
    !!tr("field_or_average") := `Field or Average`,
    !!tr("texture") := Texture
  )
```

```{r combine-producer-and-summaries}
# Combine producer table with summaries
producer_table <- producer_samples |>
  dplyr::select(
    measurement_group,
    abbr,
    value,
    !!tr("field_or_average") := field_name,
    Textura = texture
  )

# Bind together into one df and round values to 2 digits
df_table <- dplyr::bind_rows(
  producer_table,
  crop_summary,
  county_summary,
  project_summary
) |>
  dplyr::mutate(
    value = as.numeric(formatC(value, 2, drop0trailing = TRUE))
  )
```

```{r split-into-groups}
# Split into list with each measurement group as its own df and pivot wider
groups <- df_table |>
  split(df_table$measurement_group) |>
  purrr::map(\(x) {
    tidyr::pivot_wider(
      x,
      id_cols = c(tr("field_or_average"), tr("texture")),
      names_from = abbr
    )
  })
```

```{r physical-group-tweaks}
# Special wrangling for texture

# Extract physical df from averages list
physical <- setNames(
  list(groups[[tr("physical_group")]]),
  tr("physical_group")
)

# Remove texture from all dataframes except physical
groups <- purrr::map(
  subset(
    groups,
    !(names(groups) == tr("physical_group"))
  ),
  \(x) dplyr::select(x, -!!tr("texture"))
)

# Add physical df back to the averages list
groups <- c(groups, physical)

# Remove this intermediate variable from env
rm(physical)
```

```{r remove-rows-with-one-observation}
# Delete any county or crop averages where n = 1 or county/crop is blank.

# e.g. ^1 Fields)|NA or ^1 Campos)|NA
search <- paste0("(^1 ", tr("fields"), ")|NA")

tables <- groups |>
  purrr::map(~ filter(.x, !grepl(search, !!sym(tr("field_or_average")))))

# Order list of tables based on how they appear in dictionary. Important that
# tables and headers are in the same order for the make-flextables chunk.
tables <- tables[measurement_groups]
```

```{r get-headers-for-flextable}
# Map function to each measurement group, resulting in a new df with
# abbreviations and units in a list for make_ft()
headers <- results_long |>
  soils::pull_unique(target = measurement_group) |>
  as.list() |>
  rlang::set_names() |>
  purrr::map(\(group) {
    get_table_headers(dictionary, group) |>
      dplyr::mutate(dplyr::across(
        c(1, 2),
        \(x) gsub("Field or Average", tr("field_or_average"), x)
      ))
  })
```

```{r make-flextables}
# Create a list containing a flextable for each measurement group
table_list <- list2DF(
  list(
    table = tables,
    header = headers
  )
) |>
  purrr::pmap(\(table, header) {
    soils::make_ft(table, header) |>
      soils::format_ft_colors(
        lighter_color = lighter_color,
        darker_color = darker_color,
        language = str_to_title(params$language)
      ) |>
      soils::style_ft(
        header_font = header_font,
        body_font = body_font,
        header_color = header_color,
        header_text_color = header_text_color,
        border_color = border_color
      ) |>
      soils::unit_hline(header = header) |>
      flextable::set_table_properties(layout = "autofit")
  })
```

<!-- Plots -->

```{r prep-df-plot}
# Prep df for texture triangle and strip plots
df_plot <- results_long |>
  dplyr::mutate(
    # Dummy column to set x-axis in same place for each facet
    dummy = "dummy",
    # Set category to group samples
    category = dplyr::case_when(
      sample_id %in% producer$sample_id ~ tr("your_fields"),
      crop %in% producer$crop & !is.na(crop) ~ tr("same_crop"),
      county %in% producer$county & !is.na(county) ~ tr("same_county"),
      .default = tr("other_fields")
    ),
    # Set category factors so producer samples are plotted last
    category = factor(
      category,
      levels = c(
        tr("your_fields"),
        tr("same_crop"),
        tr("same_county"),
        tr("other_fields")
      )
    ),
    # Label for tooltip
    label = dplyr::case_when(
      category == tr("your_fields") ~ glue::glue(
        "{field_name}<br>{crop}<br>{value} {unit}"
      ),
      category == tr("same_crop") ~ glue::glue(
        "{crop}<br>{value} {unit}"
      ),
      category == tr("same_county") ~ glue::glue(
        "{county}<br>{value} {unit}"
      ),
      .default = glue::glue(
        "{value} {unit}",
        .na = ""
      )
    )
  )

# Order the df so producer's points are plotted on top
df_plot <- df_plot[order(df_plot$category, decreasing = TRUE), ]
```


```{r prep-texture-triangle}
# Make sure dataset has sand, silt, and clay measurements
texture <- dplyr::filter(
  producer_samples,
  abbr %in% c(tr("sand"), tr("silt"), tr("clay"))
)

# Select only the texture variables from the plot df and pivot so each texture
# is in its own column
texture_df <- df_plot |>
  dplyr::filter(abbr %in% c(tr("sand"), tr("silt"), tr("clay"))) |>
  tidyr::pivot_wider(
    id_cols = c(
      sample_id,
      category
    ),
    names_from = measurement
  ) |>
  # Texture must be in the order: sand, silt, clay, category
  dplyr::select(
    dplyr::contains("sand"),
    dplyr::contains("silt"),
    dplyr::contains("clay"),
    category
  )

# Split by category then drop category column
texture_list <- split(texture_df, texture_df$category) |>
  purrr::map(\(df) dplyr::select(df, -category))

# Does producer have sand, silt, and clay for at least 1 sample?
producer_texture <- texture_df |>
  dplyr::filter(category == tr("your_fields")) |>
  dplyr::select(-category)

make_tt <- all(grepl(
  "sand|silt|clay",
  colnames(producer_texture),
  ignore.case = TRUE
)) & ncol(producer_texture) == 3
```

```{r make-texture-triangle}
# Only create texture triangle if above prep-texture-triangle ran
if (make_tt) {
  # Since the texture triangle is made with base R plotting functions, we need
  # to set our graphics device to save it as a PNG for embedding in our report.
  ragg::agg_png(
    "figure-output/texture-triangle.png",
    res = 150,
    width = 1200,
    height = 1000,
    scaling = 1
  )

  # Create the texture triangle
  soils::make_texture_triangle(body_font = body_font)

  # The two character code glued to the end of the six character hex color is
  # the opacity level. The opacity value ranges from 00 to FF, with 00 being
  # fully transparent and FF being fully opaque. See a chart to find the opacity
  # code for the level of transparency you want:
  # https://drawne.com/hex-opacity/.

  # Add points for other fields on the bottom
  soils::add_texture_points(
    texture_list[[tr("other_fields")]],
    color = glue::glue(other_color, "CC"),
    bg = glue::glue(other_color, 99),
    pch = 21,
    size = 1.36
  )

  # Next add points for sampe crop
  soils::add_texture_points(
    texture_list[[tr("same_crop")]],
    color = glue::glue("#918D8D", "CC"),
    bg = glue::glue("#918D8D", 99),
    pch = 24,
    size = 1.36
  )

  # Next add points for same county
  soils::add_texture_points(
    texture_list[[tr("same_county")]],
    color = glue::glue("#494646", "CC"),
    bg = glue::glue("#494646", 99),
    pch = 8,
    size = 2
  )

  # Lastly, add points for 'Su campo' on top of the other layers
  soils::add_texture_points(
    texture_list[[tr("your_fields")]],
    color = glue::glue(primary_color, "FF"),
    bg = glue::glue(primary_color, "CC"),
    pch = 22,
    size = 2.4
  )

  # Add the legend
  soils::add_legend(
    legend = c(
      tr("your_fields"),
      tr("same_county"),
      tr("same_crop"),
      tr("other_fields")
    ),
    color = c(
      primary_color,
      secondary_color,
      "#918D8D",
      other_color
    ),
    pt.bg = c(
      glue::glue(primary_color, "CC"),
      glue::glue("#494646", 99),
      glue::glue("#918D8D", 99),
      glue::glue(other_color, 99)
    ),
    pch = c(22, 8, 24, 21),
    size = c(2.4, 2, 1.36, 1.36),
    vertical_spacing = 1.5
  )

  # Turn off the graphics device to save the figure
  invisible(dev.off())

  # Remove the extra white space around the figure if magick is installed
  if (requireNamespace("magick", quietly = TRUE)) {
    tt <- magick::image_read("figure-output/texture-triangle.png")
    tt <- magick::image_trim(tt)
    magick::image_write(tt, "figure-output/texture-triangle.png")
  }
}
```

```{r make-strip-plots}
# Split df_plot into a list with each measurement group in its own plot
plot_list <- df_plot |>
  split(df_plot$measurement_group) |>
  purrr::map(\(group) {
    # Make strip plot
    plot <- soils::make_strip_plot(
      group,
      color = category,
      fill = category,
      size = category,
      shape = category,
      alpha = category,
      language = str_to_title(params$language)
    ) |>
      # Set color, size, shape, alpha scales
      set_scales(
        primary_color = primary_color,
        secondary_color = secondary_color,
        other_color = other_color,
        language = str_to_title(params$language)
      ) +
      # Apply facet strip plot theme
      soils::theme_facet_strip(
        body_font = body_font,
        strip_color = strip_color,
        strip_text_color = strip_text_color
      )
  })
```

<!-- PROJECT SUMMARY TEXT -->
`r params$project_summary`

<!-- SOIL HEALTH TEXT -->
`r get_text(section = "soil_health", content_dir = params$language)`


<!-- SOIL QUALITIES TEXT -->
::: {.content-visible when-format="html"}
::: {.callout-tip icon="false"}
`r get_text(section = "soil_qualities", content_dir = params$language)`
:::
:::

::: {.content-visible unless-format="html"}
```{r echo=FALSE}
qualities <- parse_bullets_from_markdown(
  section = "soil_qualities",
  content_dir = params$language
)

flextable::flextable(qualities)
```
:::

<!-- SOIL SCIENCE TEXT -->
`r get_text(section = "soil_science", content_dir = params$language)`

<!-- WHAT WE MEASURE IN YOUR SOIL TEXT -->
`r get_text(section = "measured_soil", content_dir = params$language)`

\n

<!--If output is HTML, definitions in tabset panel -->
::: {.content-visible when-format="html"}
::: panel-tabset
```{r, results='asis'}
for (measure_type in distinct_selected_measure_types) {
  # Get measures belonging to this type
  measures_in_type <- selected_measures |>
    filter(section_name == measure_type)

  # Measure group image path
  image <- paste0("![](images/", tolower(measures_in_type$type[1]), ".png)")

  # Header color
  color <- section_colors$color[section_colors$name == measure_type]

  # Apply inline styling to measure group  header
  styled_header <- paste0("## [**", measure_type, "**]{style='color:", color, "'}")

  # Print the measure group header with image
  cat(styled_header, image, "\n\n")

  # Include each measure file in group
  for (measure in measures_in_type$file_name) {
    cat("{{< include ", params$language, "/", measure, " >}}\n\n", sep = "")
  }
}
```
:::
:::

<!--If output is word, definitions as text -->
::: {.content-visible unless-format="html"}
```{r, results='asis'}
for (measure_type in distinct_selected_measure_types) {
  # Print the section header
  cat("##", measure_type, "\n\n")

  # Get measures belonging to this type
  measures_in_type <- selected_measures |>
    filter(type == measure_type) |>
    pull(file_name)

  # Include each measure file
  for (measure in measures_in_type) {
    cat("{{< include ", params$language, "/", measure, " >}}\n\n", sep = "")
  }
}
```
:::

{{< pagebreak >}}

<!-- SOIL HEALTH INDICATOS TEXT -->
`r get_text(section = "indicators", content_dir = params$language)`

```{r indicator-table}
# read in data to generate indicators table, ignore empty rows
indicators <- selected_measures[, 6:9]
indicators <- indicators[!apply(
  indicators,
  1,
  function(row) all(is.na(row) | row == "")
), ]
names(indicators) <- gsub("\\.", " ", names(indicators))

# grouping column name always indexed at 3 (post-subset)
indicator_groups <- colnames(indicators)[3]

# generate flextable
flextable::as_grouped_data(indicators, groups = indicator_groups) |>
  flextable::as_flextable() |>
  soils::style_ft(
    header_font = header_font,
    body_font = body_font,
    header_color = header_color,
    header_text_color = header_text_color,
    border_color = border_color
  ) |>
  # @jadeyryan need help determining how to handle logic
  # flextable::bg(i = ~ !is.na(`Medir cada`), bg = lighter_color) |>
  flextable::set_table_properties(layout = "autofit")
```

{{< pagebreak >}}

<!-- YOUR FIELDS TEXT -->
`r get_text(section = "your_fields", content_dir = params$language)`

```{r}
# do not add chunk label due to bug
# https://github.com/quarto-dev/quarto-cli/issues/3603
gis_ft <- gis_df |>
  dplyr::select(
    !!tr("sample_id") := sample_id,
    !!tr("field_id") := field_id,
    !!tr("field_name") := field_name,
    !!tr("crop") := crop,
    !!tr("longitude") := longitude,
    !!tr("latitude") := latitude
  )

# If crop is empty, remove the column from the printed table
if (all(is.na(gis_ft[[tr("crop")]]))) {
  gis_ft <- gis_ft |>
    select(-all_of(tr("crop")))
}
# If longitude or latitude are empty, remove the columns from the printed table
if (all(is.na(gis_ft[[tr("longitude")]])) |
  all(is.na(gis_ft[[tr("latitude")]]))) {
  gis_ft <- gis_ft |>
    select(-any_of(c(tr("longitude"), tr("latitude"))))
}

gis_ft |>
  flextable::flextable() |>
  soils::style_ft(
    header_font = header_font,
    body_font = body_font,
  ) |>
  flextable::set_table_properties(layout = "autofit")
```

<!-- The below "\" is a hard line break that works for html and docx. -->

\

```{r html-map}
#| eval: !expr out_type == "html"

if (!NA %in% gis_df$longitude & !NA %in% gis_df$latitude) {
  soils::make_leaflet(
    gis_df,
    primary_color = primary_color
  )
}
```

```{r static-map}
#| eval: !expr out_type == "docx"
#| out-width: 6in

if (!NA %in% gis_df$longitude & !NA %in% gis_df$latitude) {
  df_sf <- sf::st_as_sf(
    x = gis_df,
    coords = c("longitude", "latitude"),
    crs = "+proj=lonlat"
  ) |>
    sf::st_transform(3857)

  basetiles <- maptiles::get_tiles(
    df_sf,
    provider = "Esri.WorldStreetMap",
    cachedir = tempdir(),
    retina = TRUE
  )

  map <- ggplot2::ggplot(df_sf) +
    tidyterra::geom_spatraster_rgb(data = basetiles) +
    ggplot2::geom_sf(color = primary_color, size = 3) +
    ggrepel::geom_label_repel(
      ggplot2::aes(label = field_id, geometry = geometry),
      stat = "sf_coordinates",
      family = body_font,
      size = 3,
      point.padding = 2,
      min.segment.length = 0
    ) +
    ggplot2::coord_sf(crs = 3857) +
    ggplot2::theme_void()

  ggplot2::ggsave(glue::glue("{path}/map.png"), map, dpi = 300)

  knitr::include_graphics(
    glue::glue("{path}/map.png")
  )
}
```

{{< pagebreak >}}


<!-- PROJECT RESULTS TEXT -->
`r get_text(section = "project_results", content_dir = params$language)` `r params$soil_depth`.

```{r create-measurement-group-sections}
#| output: asis

# Add section for each measurement group containing a header, texture triangle
# (for the physical group), table, and plot.
sections <- purrr::map_chr(measurement_groups, \(group) {
  knitr::knit_child(
    input = "section_template.qmd",
    envir = rlang::env(),
    quiet = TRUE
  )
})

cat(sections, sep = "\n")
```

<!-- LOOKING FORWARD TEXT -->
`r get_text(section = "looking_forward", content_dir = params$language)`
`r params$looking_forward`

<!-- ACKNOWLEDGEMENTS TEXT -->
`r get_text(section = "acknowledgements", content_dir = params$language)`
